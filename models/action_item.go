// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ActionItem action item
//
// swagger:model actionItem
type ActionItem struct {

	// Specify the type of UI component to use to display this action or state. The corresponding field must also be included. For example, if you specify "switch" here, you must also include the "switch" key and its object definition for this action or state.
	// Required: true
	// Enum: [pushButton toggleSwitch switch standbyPowerSwitch playPause playStop]
	DisplayType *string `json:"displayType"`

	// group
	Group Group `json:"group,omitempty"`

	// play pause
	PlayPause *PlayPause `json:"playPause,omitempty"`

	// play stop
	PlayStop *PlayStop `json:"playStop,omitempty"`

	// push button
	PushButton *PushButton `json:"pushButton,omitempty"`

	// standby power switch
	StandbyPowerSwitch *StandbyPowerSwitchForDashboard `json:"standbyPowerSwitch,omitempty"`

	// switch
	Switch *SwitchForDashboard `json:"switch,omitempty"`

	// toggle switch
	ToggleSwitch *ToggleSwitchForDashboard `json:"toggleSwitch,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ActionItem) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		DisplayType *string `json:"displayType"`

		Group Group `json:"group,omitempty"`

		PlayPause *PlayPause `json:"playPause,omitempty"`

		PlayStop *PlayStop `json:"playStop,omitempty"`

		PushButton *PushButton `json:"pushButton,omitempty"`

		StandbyPowerSwitch *StandbyPowerSwitchForDashboard `json:"standbyPowerSwitch,omitempty"`

		Switch *SwitchForDashboard `json:"switch,omitempty"`

		ToggleSwitch *ToggleSwitchForDashboard `json:"toggleSwitch,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.DisplayType = dataAO0.DisplayType

	m.Group = dataAO0.Group

	m.PlayPause = dataAO0.PlayPause

	m.PlayStop = dataAO0.PlayStop

	m.PushButton = dataAO0.PushButton

	m.StandbyPowerSwitch = dataAO0.StandbyPowerSwitch

	m.Switch = dataAO0.Switch

	m.ToggleSwitch = dataAO0.ToggleSwitch

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ActionItem) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		DisplayType *string `json:"displayType"`

		Group Group `json:"group,omitempty"`

		PlayPause *PlayPause `json:"playPause,omitempty"`

		PlayStop *PlayStop `json:"playStop,omitempty"`

		PushButton *PushButton `json:"pushButton,omitempty"`

		StandbyPowerSwitch *StandbyPowerSwitchForDashboard `json:"standbyPowerSwitch,omitempty"`

		Switch *SwitchForDashboard `json:"switch,omitempty"`

		ToggleSwitch *ToggleSwitchForDashboard `json:"toggleSwitch,omitempty"`
	}

	dataAO0.DisplayType = m.DisplayType

	dataAO0.Group = m.Group

	dataAO0.PlayPause = m.PlayPause

	dataAO0.PlayStop = m.PlayStop

	dataAO0.PushButton = m.PushButton

	dataAO0.StandbyPowerSwitch = m.StandbyPowerSwitch

	dataAO0.Switch = m.Switch

	dataAO0.ToggleSwitch = m.ToggleSwitch

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this action item
func (m *ActionItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDisplayType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlayPause(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlayStop(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePushButton(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStandbyPowerSwitch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSwitch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToggleSwitch(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var actionItemTypeDisplayTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pushButton","toggleSwitch","switch","standbyPowerSwitch","playPause","playStop"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		actionItemTypeDisplayTypePropEnum = append(actionItemTypeDisplayTypePropEnum, v)
	}
}

// property enum
func (m *ActionItem) validateDisplayTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, actionItemTypeDisplayTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ActionItem) validateDisplayType(formats strfmt.Registry) error {

	if err := validate.Required("displayType", "body", m.DisplayType); err != nil {
		return err
	}

	// value enum
	if err := m.validateDisplayTypeEnum("displayType", "body", *m.DisplayType); err != nil {
		return err
	}

	return nil
}

func (m *ActionItem) validateGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.Group) { // not required
		return nil
	}

	if err := m.Group.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("group")
		}
		return err
	}

	return nil
}

func (m *ActionItem) validatePlayPause(formats strfmt.Registry) error {

	if swag.IsZero(m.PlayPause) { // not required
		return nil
	}

	if m.PlayPause != nil {
		if err := m.PlayPause.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("playPause")
			}
			return err
		}
	}

	return nil
}

func (m *ActionItem) validatePlayStop(formats strfmt.Registry) error {

	if swag.IsZero(m.PlayStop) { // not required
		return nil
	}

	if m.PlayStop != nil {
		if err := m.PlayStop.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("playStop")
			}
			return err
		}
	}

	return nil
}

func (m *ActionItem) validatePushButton(formats strfmt.Registry) error {

	if swag.IsZero(m.PushButton) { // not required
		return nil
	}

	if m.PushButton != nil {
		if err := m.PushButton.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pushButton")
			}
			return err
		}
	}

	return nil
}

func (m *ActionItem) validateStandbyPowerSwitch(formats strfmt.Registry) error {

	if swag.IsZero(m.StandbyPowerSwitch) { // not required
		return nil
	}

	if m.StandbyPowerSwitch != nil {
		if err := m.StandbyPowerSwitch.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("standbyPowerSwitch")
			}
			return err
		}
	}

	return nil
}

func (m *ActionItem) validateSwitch(formats strfmt.Registry) error {

	if swag.IsZero(m.Switch) { // not required
		return nil
	}

	if m.Switch != nil {
		if err := m.Switch.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("switch")
			}
			return err
		}
	}

	return nil
}

func (m *ActionItem) validateToggleSwitch(formats strfmt.Registry) error {

	if swag.IsZero(m.ToggleSwitch) { // not required
		return nil
	}

	if m.ToggleSwitch != nil {
		if err := m.ToggleSwitch.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("toggleSwitch")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ActionItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ActionItem) UnmarshalBinary(b []byte) error {
	var res ActionItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

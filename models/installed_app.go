// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InstalledApp installed app
//
// swagger:model InstalledApp
type InstalledApp struct {

	// The ID of the app.
	// Required: true
	AppID *string `json:"appId"`

	// An App maybe associated to many classifications.  A classification drives how the integration is presented
	// to the user in the SmartThings mobile clients.  These classifications include:
	// * AUTOMATION - Denotes an integration that should display under the "Automation" tab in mobile clients.
	// * SERVICE - Denotes an integration that is classified as a "Service".
	// * DEVICE - Denotes an integration that should display under the "Device" tab in mobile clients.
	// * CONNECTED_SERVICE - Denotes an integration that should display under the "Connected Services" menu in mobile clients.
	// * HIDDEN - Denotes an integration that should not display in mobile clients
	//
	// Required: true
	Classifications []string `json:"classifications"`

	// A UTC ISO-8601 Date-Time String
	// Required: true
	// Format: date-time
	CreatedDate *strfmt.DateTime `json:"createdDate"`

	// A user defined name for the installed app. May be null.
	// Max Length: 100
	DisplayName string `json:"displayName,omitempty"`

	// icon image
	IconImage *InstalledAppIconImage `json:"iconImage,omitempty"`

	// The ID of the installed app.
	// Required: true
	// Format: uuid
	InstalledAppID *strfmt.UUID `json:"installedAppId"`

	// installed app status
	// Required: true
	InstalledAppStatus InstalledAppStatus `json:"installedAppStatus"`

	// installed app type
	// Required: true
	InstalledAppType InstalledAppType `json:"installedAppType"`

	// A UTC ISO-8601 Date-Time String
	// Required: true
	// Format: date-time
	LastUpdatedDate *strfmt.DateTime `json:"lastUpdatedDate"`

	// The ID of the location to which the installed app may belong.
	// Format: uuid
	LocationID strfmt.UUID `json:"locationId,omitempty"`

	// notices
	// Required: true
	Notices []*Notice `json:"notices"`

	// owner
	// Required: true
	Owner *Owner `json:"owner"`

	// Denotes the principal type to be used with the app.  Default is LOCATION.
	// Required: true
	// Enum: [LOCATION USER_LEVEL]
	PrincipalType *string `json:"principalType"`

	// A reference to an upstream system.  For example, Behaviors would reference the behaviorId. May be null.
	//
	ReferenceID string `json:"referenceId,omitempty"`

	// Restriction tier of the install, if any.
	RestrictionTier int64 `json:"restrictionTier,omitempty"`

	// Inform the installation systems that the associated app can only be installed once within a user's account.
	//
	// Required: true
	SingleInstance bool `json:"singleInstance"`

	// ui
	UI *InstalledAppUI `json:"ui,omitempty"`
}

// Validate validates this installed app
func (m *InstalledApp) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAppID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClassifications(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIconImage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstalledAppID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstalledAppStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstalledAppType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotices(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwner(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrincipalType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSingleInstance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InstalledApp) validateAppID(formats strfmt.Registry) error {

	if err := validate.Required("appId", "body", m.AppID); err != nil {
		return err
	}

	return nil
}

var installedAppClassificationsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AUTOMATION","SERVICE","DEVICE","CONNECTED_SERVICE","HIDDEN","LABS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		installedAppClassificationsItemsEnum = append(installedAppClassificationsItemsEnum, v)
	}
}

func (m *InstalledApp) validateClassificationsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, installedAppClassificationsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InstalledApp) validateClassifications(formats strfmt.Registry) error {

	if err := validate.Required("classifications", "body", m.Classifications); err != nil {
		return err
	}

	for i := 0; i < len(m.Classifications); i++ {

		// value enum
		if err := m.validateClassificationsItemsEnum("classifications"+"."+strconv.Itoa(i), "body", m.Classifications[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *InstalledApp) validateCreatedDate(formats strfmt.Registry) error {

	if err := validate.Required("createdDate", "body", m.CreatedDate); err != nil {
		return err
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InstalledApp) validateDisplayName(formats strfmt.Registry) error {

	if swag.IsZero(m.DisplayName) { // not required
		return nil
	}

	if err := validate.MaxLength("displayName", "body", string(m.DisplayName), 100); err != nil {
		return err
	}

	return nil
}

func (m *InstalledApp) validateIconImage(formats strfmt.Registry) error {

	if swag.IsZero(m.IconImage) { // not required
		return nil
	}

	if m.IconImage != nil {
		if err := m.IconImage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iconImage")
			}
			return err
		}
	}

	return nil
}

func (m *InstalledApp) validateInstalledAppID(formats strfmt.Registry) error {

	if err := validate.Required("installedAppId", "body", m.InstalledAppID); err != nil {
		return err
	}

	if err := validate.FormatOf("installedAppId", "body", "uuid", m.InstalledAppID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InstalledApp) validateInstalledAppStatus(formats strfmt.Registry) error {

	if err := m.InstalledAppStatus.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("installedAppStatus")
		}
		return err
	}

	return nil
}

func (m *InstalledApp) validateInstalledAppType(formats strfmt.Registry) error {

	if err := m.InstalledAppType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("installedAppType")
		}
		return err
	}

	return nil
}

func (m *InstalledApp) validateLastUpdatedDate(formats strfmt.Registry) error {

	if err := validate.Required("lastUpdatedDate", "body", m.LastUpdatedDate); err != nil {
		return err
	}

	if err := validate.FormatOf("lastUpdatedDate", "body", "date-time", m.LastUpdatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InstalledApp) validateLocationID(formats strfmt.Registry) error {

	if swag.IsZero(m.LocationID) { // not required
		return nil
	}

	if err := validate.FormatOf("locationId", "body", "uuid", m.LocationID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InstalledApp) validateNotices(formats strfmt.Registry) error {

	if err := validate.Required("notices", "body", m.Notices); err != nil {
		return err
	}

	for i := 0; i < len(m.Notices); i++ {
		if swag.IsZero(m.Notices[i]) { // not required
			continue
		}

		if m.Notices[i] != nil {
			if err := m.Notices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("notices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InstalledApp) validateOwner(formats strfmt.Registry) error {

	if err := validate.Required("owner", "body", m.Owner); err != nil {
		return err
	}

	if m.Owner != nil {
		if err := m.Owner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owner")
			}
			return err
		}
	}

	return nil
}

var installedAppTypePrincipalTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LOCATION","USER_LEVEL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		installedAppTypePrincipalTypePropEnum = append(installedAppTypePrincipalTypePropEnum, v)
	}
}

const (

	// InstalledAppPrincipalTypeLOCATION captures enum value "LOCATION"
	InstalledAppPrincipalTypeLOCATION string = "LOCATION"

	// InstalledAppPrincipalTypeUSERLEVEL captures enum value "USER_LEVEL"
	InstalledAppPrincipalTypeUSERLEVEL string = "USER_LEVEL"
)

// prop value enum
func (m *InstalledApp) validatePrincipalTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, installedAppTypePrincipalTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InstalledApp) validatePrincipalType(formats strfmt.Registry) error {

	if err := validate.Required("principalType", "body", m.PrincipalType); err != nil {
		return err
	}

	// value enum
	if err := m.validatePrincipalTypeEnum("principalType", "body", *m.PrincipalType); err != nil {
		return err
	}

	return nil
}

func (m *InstalledApp) validateSingleInstance(formats strfmt.Registry) error {

	if err := validate.Required("singleInstance", "body", bool(m.SingleInstance)); err != nil {
		return err
	}

	return nil
}

func (m *InstalledApp) validateUI(formats strfmt.Registry) error {

	if swag.IsZero(m.UI) { // not required
		return nil
	}

	if m.UI != nil {
		if err := m.UI.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ui")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InstalledApp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InstalledApp) UnmarshalBinary(b []byte) error {
	var res InstalledApp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// InstalledAppIconImage A default icon image for the app.
//
// swagger:model InstalledAppIconImage
type InstalledAppIconImage struct {

	// A default icon image url for an app. https url required.
	//
	// Format: uri
	URL strfmt.URI `json:"url,omitempty"`
}

// Validate validates this installed app icon image
func (m *InstalledAppIconImage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InstalledAppIconImage) validateURL(formats strfmt.Registry) error {

	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := validate.FormatOf("iconImage"+"."+"url", "body", "uri", m.URL.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InstalledAppIconImage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InstalledAppIconImage) UnmarshalBinary(b []byte) error {
	var res InstalledAppIconImage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// InstalledAppUI A collection of settings to drive user interface in SmartThings clients.  Currently, only applicable for
// LAMBDA_SMART_APP and WEBHOOK_SMART_APP app types.
//
//
// swagger:model InstalledAppUI
type InstalledAppUI struct {

	// dashboard cards enabled
	// Required: true
	DashboardCardsEnabled *bool `json:"dashboardCardsEnabled"`

	// plugin Id
	PluginID string `json:"pluginId,omitempty"`

	// plugin Uri
	// Format: uri
	PluginURI strfmt.URI `json:"pluginUri,omitempty"`

	// pre install dashboard cards enabled
	// Required: true
	PreInstallDashboardCardsEnabled *bool `json:"preInstallDashboardCardsEnabled"`
}

// Validate validates this installed app UI
func (m *InstalledAppUI) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDashboardCardsEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePluginURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreInstallDashboardCardsEnabled(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InstalledAppUI) validateDashboardCardsEnabled(formats strfmt.Registry) error {

	if err := validate.Required("ui"+"."+"dashboardCardsEnabled", "body", m.DashboardCardsEnabled); err != nil {
		return err
	}

	return nil
}

func (m *InstalledAppUI) validatePluginURI(formats strfmt.Registry) error {

	if swag.IsZero(m.PluginURI) { // not required
		return nil
	}

	if err := validate.FormatOf("ui"+"."+"pluginUri", "body", "uri", m.PluginURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InstalledAppUI) validatePreInstallDashboardCardsEnabled(formats strfmt.Registry) error {

	if err := validate.Required("ui"+"."+"preInstallDashboardCardsEnabled", "body", m.PreInstallDashboardCardsEnabled); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InstalledAppUI) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InstalledAppUI) UnmarshalBinary(b []byte) error {
	var res InstalledAppUI
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
